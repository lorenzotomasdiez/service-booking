# BarberPro Backend

Backend API for BarberPro service booking platform built with Fastify, TypeScript, and Prisma.

## Tech Stack

- **Framework**: Fastify 5.6.0
- **Language**: TypeScript 5.9.2
- **Runtime**: Node.js 24.6.0
- **Database**: PostgreSQL 15 (Prisma ORM 6.15.0)
- **Cache/Sessions**: Redis 7
- **Authentication**: JWT (@fastify/jwt), OAuth 2.0 (Google)
- **Email**: Nodemailer (with MailHog for development)

## Quick Start

```bash
# Install dependencies
npm install

# Start Docker services (PostgreSQL, Redis)
cd .. && npm start

# Generate Prisma client
npm run db:generate

# Run database migrations
npm run db:migrate

# Seed database with test data
npm run seed

# Start development server
npm run dev
```

The API will be available at http://localhost:3000

## Development

### Scripts

```bash
npm run dev              # Start dev server with hot reload (tsx watch)
npm run build            # Build TypeScript to JavaScript
npm start                # Start production server
npm run lint             # Lint code with ESLint
npm run lint:fix         # Fix linting issues
npm run typecheck        # TypeScript type checking
npm run format:check     # Check code formatting
npm run format:fix       # Fix code formatting
```

### Database

```bash
npm run db:generate      # Generate Prisma client
npm run db:migrate       # Run migrations (dev)
npm run db:migrate:deploy # Deploy migrations (production)
npm run db:studio        # Open Prisma Studio
npm run seed             # Seed database
npm run db:reset         # Reset database (drop + migrate + seed)
```

### Testing

```bash
npm test                 # Run all tests
npm run test:watch       # Run tests in watch mode
npm run test:coverage    # Generate coverage report
npm run test:unit        # Run unit tests only
npm run test:integration # Run integration tests only
```

## Configuration

### Environment Variables

Create a `.env` file in the backend directory (auto-generated by Docker):

```env
# Database
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/barberpro"

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# JWT
JWT_SECRET=your-secret-key-here
JWT_REFRESH_SECRET=your-refresh-secret-here
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# Email Service
EMAIL_HOST=localhost
EMAIL_PORT=1025
EMAIL_USER=
EMAIL_PASSWORD=
EMAIL_FROM=noreply@barberpro.com
EMAIL_FROM_NAME=BarberPro

# Google OAuth 2.0
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GOOGLE_REDIRECT_URI=http://localhost:5173/auth/google/callback

# Frontend URL (for email links)
FRONTEND_URL=http://localhost:5173

# Server
PORT=3000
HOST=0.0.0.0
NODE_ENV=development
```

### OAuth Setup (Google)

#### 1. Create Google Cloud Project

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project or select existing one
3. Enable Google+ API

#### 2. Create OAuth 2.0 Credentials

1. Navigate to **APIs & Services** > **Credentials**
2. Click **Create Credentials** > **OAuth client ID**
3. Select **Web application**
4. Configure:
   - **Name**: BarberPro (or your app name)
   - **Authorized JavaScript origins**:
     - `http://localhost:5173` (development)
     - `https://yourdomain.com` (production)
   - **Authorized redirect URIs**:
     - `http://localhost:5173/auth/google/callback` (development)
     - `https://yourdomain.com/auth/google/callback` (production)
5. Click **Create**
6. Copy **Client ID** and **Client Secret**
7. Update `.env` file:
   ```env
   GOOGLE_CLIENT_ID=your-client-id-here.apps.googleusercontent.com
   GOOGLE_CLIENT_SECRET=your-client-secret-here
   GOOGLE_REDIRECT_URI=http://localhost:5173/auth/google/callback
   ```

#### 3. OAuth Consent Screen

1. Go to **OAuth consent screen**
2. Select **External** (for testing) or **Internal** (for organization)
3. Fill in required information:
   - App name: BarberPro
   - User support email
   - Developer contact email
4. Add scopes:
   - `.../auth/userinfo.email`
   - `.../auth/userinfo.profile`
   - `openid`
5. Add test users (for development)
6. Save and continue

#### 4. Security Best Practices

- **Never commit** `.env` file to version control
- Use **different credentials** for development and production
- Enable **PKCE** (Proof Key for Code Exchange) in production
- Use **HTTPS** for all production OAuth redirects
- Regularly **rotate secrets** in production

### Email Service Configuration

#### Development (MailHog)

MailHog is included in the Docker setup for local email testing.

1. MailHog web UI: http://localhost:8025
2. SMTP settings (auto-configured):
   ```env
   EMAIL_HOST=localhost
   EMAIL_PORT=1025
   EMAIL_USER=
   EMAIL_PASSWORD=
   ```
3. All emails are captured by MailHog and visible in the web UI
4. No emails are actually sent

#### Production (SMTP)

For production, use a real email service (e.g., SendGrid, AWS SES, Gmail):

**Example: Gmail SMTP**
```env
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASSWORD=your-app-password
EMAIL_FROM=noreply@yourdomain.com
EMAIL_FROM_NAME=BarberPro
```

**Example: SendGrid**
```env
EMAIL_HOST=smtp.sendgrid.net
EMAIL_PORT=587
EMAIL_USER=apikey
EMAIL_PASSWORD=your-sendgrid-api-key
EMAIL_FROM=noreply@yourdomain.com
EMAIL_FROM_NAME=BarberPro
```

**Note**: For Gmail, create an [App Password](https://support.google.com/accounts/answer/185833) instead of using your regular password.

## Authentication & Authorization

### Registration Flow

#### Email/Password Registration

1. User submits registration form: `POST /auth/register`
   - Validates email format, password strength, Argentina phone/DNI
   - Rate limited: 5 registrations per IP per hour
   - Creates user with `isVerified: false`
   - Sends verification email
   - Returns access token and refresh token

2. User receives verification email with link
   - Link format: `http://localhost:5173/verify-email?token={token}`
   - Token expires in 24 hours

3. User clicks link: `GET /auth/verify-email?token={token}`
   - Validates token
   - Marks user as verified (`isVerified: true`)
   - Deletes verification token

#### OAuth Registration (Google)

1. User clicks "Continue with Google"
2. Frontend redirects to: `GET /oauth/google`
3. User authenticates with Google
4. Google redirects back to: `GET /oauth/google/callback?code={code}`
5. Backend exchanges code for user profile
6. If user exists: login
7. If new user: create account with:
   - `authMethod: 'OAUTH'`
   - `isVerified: true` (email pre-verified by Google)
   - No password required
8. Returns access token and refresh token

### Email Verification System

**Endpoints:**

- `POST /auth/send-verification` - Send verification email (public, rate limited: 3/hour)
- `POST /auth/resend-verification` - Resend for authenticated user (rate limited: 3/hour)
- `GET /auth/verify-email?token={token}` - Verify email with token
- `GET /auth/verification-status` - Check verification status (authenticated)

**Token Lifecycle:**

- Generated when user registers or requests verification
- Stored in `EmailVerificationToken` table with bcrypt hash
- Expires after 24 hours
- Deleted after successful verification
- Cleanup job runs daily at 2 AM to remove expired tokens

**Rate Limiting:**

- Registration: 5 per IP per hour (prevents spam accounts)
- Verification emails: 3 per hour per email (prevents email bombing)
- Uses `@fastify/rate-limit` with Redis storage

### JWT Authentication

**Access Token** (15 minutes):
- Used for API authentication
- Include in Authorization header: `Bearer {token}`
- Short expiration for security

**Refresh Token** (7 days):
- Used to get new access tokens
- Stored in database for revocation
- Can be revoked on logout

**Endpoints:**

- `POST /auth/login` - Login with email/password
- `POST /auth/refresh` - Get new access token
- `POST /auth/logout` - Revoke refresh token
- `POST /auth/logout-all` - Revoke all user tokens
- `GET /auth/me` - Get current user profile
- `PUT /auth/me` - Update user profile
- `PUT /auth/password` - Change password

### Protected Routes

Use `fastify.authenticate` middleware to protect routes:

```typescript
fastify.get('/protected', {
  preHandler: [fastify.authenticate]
}, async (request, reply) => {
  const userId = (request.user as any).userId;
  // Route logic here
});
```

## API Documentation

Interactive API documentation is available when the server is running:

- **Swagger UI**: http://localhost:3000/docs
- **OpenAPI JSON**: http://localhost:3000/docs/json

All endpoints are documented with request/response schemas, authentication requirements, and examples.

## Project Structure

```
backend/
├── prisma/
│   ├── schema.prisma        # Database schema
│   ├── migrations/          # Database migrations
│   └── seed.ts              # Seed data
├── src/
│   ├── config/              # Configuration files
│   │   ├── email.config.ts  # Email service config
│   │   ├── oauth.config.ts  # OAuth config
│   │   └── redis.config.ts  # Redis config
│   ├── jobs/                # Cron jobs
│   │   └── cleanup-tokens.ts # Token cleanup job
│   ├── middleware/          # Fastify middleware
│   │   ├── validation.ts    # Request validation
│   │   └── security.ts      # Security middleware
│   ├── routes/              # API routes
│   │   ├── auth.ts          # Authentication routes
│   │   └── oauth.ts         # OAuth routes
│   ├── schemas/             # TypeBox/Zod schemas
│   │   └── auth.ts          # Auth schemas
│   ├── services/            # Business logic
│   │   ├── auth.ts          # Auth service
│   │   ├── email.service.ts # Email service
│   │   ├── oauth.service.ts # OAuth service
│   │   └── verification.service.ts # Email verification
│   ├── types/               # TypeScript types
│   │   └── oauth.types.ts   # OAuth types
│   └── index.ts             # Application entry point
├── tests/
│   ├── unit/                # Unit tests
│   │   ├── email.service.test.ts
│   │   ├── oauth.service.test.ts
│   │   └── verification.service.test.ts
│   └── integration/         # Integration tests
│       ├── oauth.test.ts
│       └── verification.test.ts
├── .env                     # Environment variables (auto-generated)
├── package.json             # Dependencies
├── tsconfig.json            # TypeScript config
└── README.md                # This file
```

## Background Jobs

### Token Cleanup Job

Automatically cleans up expired email verification tokens:

- **Schedule**: Daily at 2:00 AM (Argentina timezone)
- **Location**: `src/jobs/cleanup-tokens.ts`
- **Purpose**: Removes expired tokens to keep database optimized
- **Auto-start**: Enabled when server starts
- **Manual execution**:
  ```typescript
  import { runTokenCleanup } from './jobs/cleanup-tokens';
  await runTokenCleanup(fastify);
  ```

## Database Schema

Key models for authentication:

### User
- `id`: Unique identifier
- `email`: Unique email address
- `password`: Bcrypt hashed (nullable for OAuth users)
- `name`: User's full name
- `role`: CLIENT | PROVIDER | ADMIN
- `isVerified`: Email verification status
- `authMethod`: EMAIL | OAUTH | BOTH

### EmailVerificationToken
- `id`: Unique identifier
- `userId`: User reference
- `token`: Bcrypt hashed token (unique)
- `email`: Email being verified
- `expiresAt`: Token expiration (24 hours)
- Indexed on: `token`, `userId`, `expiresAt`

### OAuthProvider
- `id`: Unique identifier
- `userId`: User reference
- `provider`: GOOGLE | FACEBOOK
- `providerUserId`: OAuth provider's user ID
- `email`: Email from OAuth provider
- `profileData`: Additional profile info (JSON)
- `accessToken`: OAuth access token (encrypted)
- `refreshToken`: OAuth refresh token (encrypted)

### RefreshToken
- `id`: Unique identifier
- `userId`: User reference
- `token`: JWT refresh token (unique)
- `expiresAt`: Token expiration
- `isRevoked`: Revocation status

## Security Features

### Password Security
- Bcrypt hashing with salt rounds: 10
- Minimum 8 characters
- Required: uppercase, lowercase, number, special character
- Password validation on registration and password change

### Token Security
- Email verification tokens hashed with bcrypt
- JWT tokens with short expiration
- Refresh token rotation on use
- Token revocation on logout
- Cascade delete on user deletion

### Rate Limiting
- Registration: 5 per IP per hour
- Verification emails: 3 per hour per email
- Uses `@fastify/rate-limit` with Redis
- Returns 429 Too Many Requests on limit exceeded

### OAuth Security
- PKCE (Proof Key for Code Exchange) enabled
- HTTPS required for production redirects
- State parameter for CSRF protection
- Tokens encrypted at rest
- Scopes limited to email and profile

### CORS
- Configured for frontend origin only
- Credentials enabled for cookies
- Pre-flight requests handled

## Monitoring & Logging

### Logging
- Pino logger with pretty printing in development
- Structured logging with context
- Error stack traces in development
- Log levels: trace, debug, info, warn, error, fatal

### Health Checks
- Database connection status
- Redis connection status
- Email service status (ping SMTP)

## Performance Optimization

### Database Indexes
- `EmailVerificationToken.token` - Unique index for fast lookups
- `EmailVerificationToken.userId` - Index for user queries
- `EmailVerificationToken.expiresAt` - Index for cleanup job
- `User.email` - Unique index for login
- `User.isVerified` - Index for verification queries
- `OAuthProvider.provider + providerUserId` - Composite unique index

### Caching
- Redis caching for session data
- Rate limit counters in Redis
- Token blacklist in Redis (for logout)

### Connection Pooling
- Prisma connection pooling (default: 10 connections)
- Redis connection pooling

## Deployment

### Production Checklist

- [ ] Set `NODE_ENV=production`
- [ ] Use strong `JWT_SECRET` and `JWT_REFRESH_SECRET`
- [ ] Configure real SMTP email service
- [ ] Set up Google OAuth production credentials
- [ ] Enable HTTPS for all endpoints
- [ ] Configure CORS for production domain
- [ ] Set up database backups
- [ ] Configure Redis persistence
- [ ] Enable application monitoring
- [ ] Set up error tracking (e.g., Sentry)
- [ ] Configure rate limiting with stricter limits
- [ ] Enable security headers
- [ ] Set up SSL/TLS certificates
- [ ] Configure firewall rules
- [ ] Enable database query logging
- [ ] Set up automated database migrations

### Docker Deployment

```bash
# Build image
npm run docker:build

# Run container
npm run docker:run
```

### Railway/AWS Deployment

Follow deployment scripts in `/backend/scripts/`:
- `deploy-production.sh production` - Deploy to production
- `deploy-production.sh staging` - Deploy to staging
- `deploy-production.sh rollback` - Rollback last deployment

## Troubleshooting

### Database Connection Issues
```bash
# Check PostgreSQL is running
docker ps | grep postgres

# Check connection string
echo $DATABASE_URL

# Reset database
npm run db:reset
```

### Email Not Sending
```bash
# Check MailHog is running (development)
curl http://localhost:8025

# Check email configuration
cat .env | grep EMAIL

# Test email service
npm run test:integration -- email.service.test.ts
```

### OAuth Not Working
```bash
# Verify OAuth credentials
cat .env | grep GOOGLE

# Check redirect URI matches Google Console
# Check frontend URL is correct
# Verify user is in test users list (development)
```

### Rate Limiting Issues
```bash
# Check Redis is running
docker ps | grep redis

# Connect to Redis
redis-cli

# Check rate limit keys
KEYS *rate-limit*

# Clear rate limits (development only)
FLUSHDB
```

## Contributing

1. Follow TypeScript strict mode
2. Write tests for new features
3. Use Spanish for user-facing error messages
4. Follow Argentina-specific validations (phone, DNI, CUIT)
5. Update documentation for API changes
6. Run linting and tests before committing

## License

Proprietary - BarberPro
